/**
 * @class Paradigm
 *
 * @author Mauro Trevisan
 */
define(['tools/lang/phonology/Word', 'tools/lang/Dialect', 'tools/lang/morphology/Themizer', 'tools/lang/phonology/PhonologyHelper', 'tools/data/ObjectHelper'], function(Word, Dialect, Themizer, PhonologyHelper, ObjectHelper){

	/** @constant */
	var REGULAR = 'regular',
	/** @constant */
		IRREGULAR = 'irregular',
	/** @constant */
		PRONOMENAL_MARK = '#',
	/** @constant */
		PRONOMENAL_MARK_IMPERATIVE = '$';


	var Constructor = function(){};


	/**
	 * @param {List} List of verbs generated by Verb
	 */
	var generate = function(verbs){
		var dialect = new Dialect(),
			themesEndings = {},
			paradigmEndings = {},
			infinitives = [],
			infinitive, themes;
		verbs.forEach(function(verb){
			if(infinitives.indexOf(verb.infinitive) < 0){
				infinitive = Word.unmarkDefaultStress(verb.infinitive);

				infinitives.push(infinitive);

				themes = Themizer.generate(verb, dialect);

				verb.infinitive = infinitive;

//				generateThemesForSingleVerb(verb, themes, themesEndings);
				generateEndingsForSingleVerb(verb, themes, paradigmEndings);
			}
		});

//		constraintToInfinitives(themesEndings, infinitives);
		constraintToInfinitives(paradigmEndings, infinitives);

//console.log(themesEndings);
console.log(paradigmEndings);
	};


	/**
	 * @param {Verb} verb generated by Verb
	 * @param {Object} themes generated by Themizer
	 */
	var generateThemesForSingleVerb = function(verb, themes, themesEndings){
		var te, idx, from, to;
		visit(themes, function(obj, key, id){
			te = namespace(themesEndings, id, key);

			idx = extractIndexOfCommonPartFromStart(verb.infinitive, obj[key]);
			from = verb.infinitive.substr(idx);
			to = obj[key].substr(idx);

			idx = findIndex(te, function(el){ return (el.from == from && el.to == to); });
			if(idx < 0)
				te.push({from: from, to: to, parents: [verb.infinitive]});
			else
				te[idx].parents.push(verb.infinitive);
		});
	};

	/** @private */
	var visit = function(obj, funct, id){
		for(var key in obj)
			if(obj.hasOwnProperty(key) && !obj.matcher){
				if(!ObjectHelper.isString(obj[key]) && !obj.parents)
					visit(obj[key], funct, (id? id + '.' + key: key));
				else
					funct(obj, key, id);
			}
	};

	/** @private */
	var namespace = function(obj, id, key){
		var p = path(obj, id);
		return (p[key] = p[key] || []);
	};

	/** @private */
	var path = function(obj, id){
		var ids = id.split('.'),
			size = ids.length,
			i, k;
		for(i = 0; i < size; i ++){
			k = ids[i];
			obj = (obj[k] = obj[k] || {});
		}
		return obj;
	};

	/** @private */
	var extractIndexOfCommonPartFromStart = function(a, b){
		for(var i = 0, len = Math.min(a.length, b.length); i < len; i ++)
			if(a[i] != b[i])
				break;
		return i;
	};

	/** @private */
	var extractCommonPartFromEnd = function(a, b){
		for(var i = 0, len = Math.min(a.length, b.length); i < len; i ++)
			if(a[a.length - i - 1] != b[b.length - i - 1])
				break;
		return (i > 0? a.substr(a.length - i): '');
	};

	/** @private */
	var extractCommonPartFromList = function(list){
		var form;
		list.forEach(function(el, i){
			form = (!i? el: extractCommonPartFromEnd(el, form));
		});
		return form;
	};

	/** @private */
	var constraintToInfinitives = function(list, infinitives){
		var diff, variab, variability, common, re, found, part, partitioningResults, parentsTrue, parentsFalse, listNoPrefixes, first;
		visit(list, function(obj, key, id){
			diff = difference(infinitives, obj.parents);

			common = extractCommonPartFromList(obj.parents);
			variability = '';
			re = new RegExp(common + '$');
			found = diff.some(function(el){ return el.match(re); });

			if(found && obj.parents.indexOf(common) < 0){
				variab = extractVariability(common.length, 1, obj.parents);
				variability = listToRegExp(variab);
				re = new RegExp(variability + common + '$');
				found = diff.some(function(el){ return el.match(re); });
			}

			if(found){
				if(obj.parents.length == 1){
					obj.matcher = '^' + obj.parents[0];

					return;
				}

				part = partition(obj.parents, function(el, idx){ return (el.length - common.length >= 1? el[el.length - common.length - 1]: '^'); });
				if(!part['^']){
					variability = listToRegExp(extractVariability(common.length + 1, 1, obj.parents));
					partitioningResults = {'true': [], 'false': []};
					Object.keys(part).forEach(function(k){
						re = new RegExp(variability + k + common + '$');
						partitioningResults[diff.some(function(el){ return el.match(re); })].push(k);
					});
					if(partitioningResults['true'].length && partitioningResults['false'].length){
						parentsTrue = [];
						parentsFalse = [];
						partitioningResults['true'].forEach(function(k){
							parentsTrue = parentsTrue.concat(part[k]);
						});
						partitioningResults['false'].forEach(function(k){
							parentsFalse = parentsFalse.concat(part[k]);
						});

						obj.matcher = listToRegExp(partitioningResults['false']) + common;
						obj.parents = parentsFalse;


						obj = {parents: parentsTrue, suffixes: obj.suffixes};
						path(list, id.replace(/\.[^\.]+$/, '')).push(obj);
						if(obj.parents.indexOf(common) < 0){
							variability = listToRegExp(extractVariability(common.length + 1, 1, obj.parents));
							re = new RegExp(variability + listToRegExp(partitioningResults['true']) + common + '$');
							found = diff.some(function(el){ return el.match(re); });
						}
					}
					else if(!partitioningResults['true'].length){
						obj.matcher = variability + listToRegExp(Object.keys(part)) + common;

						return;
					}
				}
			}

			if(found){
				common = extractCommonPartFromList(diff);
				variability = listToNotRegExp(extractVariability(common.length, 1, diff));
				re = new RegExp(variability + common + '$');
				found = !obj.parents.every(function(el){ return el.match(re); });
			}


			if(found){
				console.log('error! cannot split up the initial verbs array');

				/*listNoPrefixes = uniqueNoPrefixes(obj.parents);
				first = listNoPrefixes.shift();
				obj.matcher = '^' + first;

				if(listNoPrefixes.length){
					listNoPrefixes.forEach(function(el){
						list[id.replace(/(\..+)$/, '')].push({matcher: el, parents: listNoPrefixes.slice(0).splice(listNoPrefixes.indexOf(el), 1), suffixes: obj.suffixes});
					});

					obj.parents = [first];
				}/**/
			}
			else
				obj.matcher = variability + common;


			/*if(form && (obj.matcher == form || extractCommonPartFromEnd(form, obj.matcher).length)){
				found = false;
				not = false;
				order = 1;
				do{
					variability = extractVariability(obj.matcher.length, order ++, obj.parents);
					if(!variability.length){
						found = false;
						break;
					}
					variability = listToRegExp(variability);

					matcher = new RegExp(variability + obj.matcher + '$');
					found = (findIndex(diff, function(el){ return el.match(matcher); }) >= 0);

					if(found && order == 2){
						not = true;
						variability = listToNotRegExp(extractVariability(form.length, order - 1, obj.parents));

						matcher = new RegExp(variability + form + '$');
						found = (findIndex(diff, function(el){ return el.match(matcher); }) >= 0);
					}
				}while(found && !diff.every(function(el){ return (el[0] == '^'); }));
				if(!found)
					obj.matcher = variability + (not? form: obj.matcher);
				else
					console.log('error! cannot split up the initial verbs array');
			}/**/
		});
	};

	/** @private */
	var difference = function(a, b){
		return a.filter(function(x){ return (b.indexOf(x) < 0); });
	};

	/** @private */
	var extractVariability = function(formLength, order, list){
		var variability = [],
			idx;
		list.forEach(function(obj){
			idx = obj.length - formLength - order;
			variability.push(idx >= 0? obj.substr(idx, order): '.');
		});
		return unique(variability).sort();
	};

	/** @private */
	var listToRegExp = function(list){
		if(list.length == 1)
			return list[0];
		return (list[list.length - 1].length == 1? '[' + list.join('') + ']': '(' + list.join('|') + ')');
	};

	/** @private */
	var listToNotRegExp = function(list){
		return (list[list.length - 1].length == 1? '[^' + list.join('') + ']': '(?!' + list.join('|') + ')');
//		return listToRegExp(list).replace(/^\[/, '[^').replace(/^\(/, '(?!');
	};

	/** @private */
	var unique = function(list){
		return list.filter(function(x, i){
			return (list.indexOf(x) == i);
		});
	};

	/** @private */
	var uniqueNoPrefixes = function(list){
		return list.filter(function(x){
			for(var i = 0, len = list.length; i < len; i ++)
				if(x.indexOf(list[i]) > 0)
					return false;
			return true;
		});
	};

	var partition = function(list, predicate){
		var result = {};
		list.forEach(function(value, index){
			var key = predicate(value, index, list);
			if(key in result)
				result[key].push(value);
			else
				result[key] = [value];
		});
		return result;
	};


	/**
	 * @param {Verb} verb generated by Verb
	 * @param {Object} themes generated by Themizer
	 */
	var generateEndingsForSingleVerb = function(verb, themes, paradigmEndings){
		this.verb = verb;
		this.themes = themes;
		this.paradigmEndings = paradigmEndings;

		var reg = this.themes[REGULAR],
			irr = this.themes[IRREGULAR],
			pronomenalMark = (!this.verb.infinitive.match(/(déver|(^|[^t])èser|s?avér)$/)? PRONOMENAL_MARK: ''),
			conj, suffixes;

		[REGULAR, IRREGULAR].forEach(function(type){
			var t = this.themes[type];

			conj = getIrregularVerbConjugation.call(this, type);

			generateThemeT1.call(this, t, pronomenalMark);
			generateThemeT2_sto.call(this, t);
			if(t.themeT5){
				suffixes = ['', 'é>e+mo'];
				if(conj == 2){
					suffixes = suffixes.concat(['i?é>í', 'i?é>i+mo']);
				}
				if(!this.verb.irregularity.poder){
					suffixes = suffixes.concat([PRONOMENAL_MARK_IMPERATIVE]);
					if(conj == 2)
						suffixes = suffixes.concat(['i?é>í+' + PRONOMENAL_MARK_IMPERATIVE]);
					else
						suffixes = suffixes.concat(['[èí]>é+' + PRONOMENAL_MARK_IMPERATIVE]);
				}
				upsert(this.paradigmEndings, 't5', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			if(t.themeT6){
				suffixes = ['(do)', 'o', '(d)i', '', '(d)a', '(d)e'];
				upsert(this.paradigmEndings, 't6', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			if(t.themeT7)
				upsert(this.paradigmEndings, 't7', {parents: [this.verb.infinitive],
					suffixes: ['nte', 'sto', 'sti', 'sta', 'ste']});
			if(t.themeT8){
				var third = t.themeT8 + (!this.verb.irregularity.verb.match(/darStarFar|s?aver/)? (this.verb.irregularity.eser? 'é': 'e'): '');
				suffixes = [(!this.verb.irregularity.verb.match(/andar|darStarFar|s?aver/) || !t.themeT8.match(/à$/)? '([^i])>$1+i': '([^i])>$1'),
					(!this.verb.irregularity.verb.match(/darStarFar|s?aver/)? (this.verb.irregularity.eser? 'é': 'e'): '')];
				if(third.match(/[ei]$/))
					suffixes = suffixes.concat(['[ei]>+voicing']);
				if(this.verb.irregularity.eser)
					suffixes = suffixes.concat([(!t.themeT8.match(/[cijɉñ]$/)? '(i)': '') + 'on']);
				else if(this.verb.irregularity.aver)
					suffixes = suffixes.concat(['', 'à>[èò]']);
				else{
					suffixes = suffixes.concat(['e', 'o']);

					if(this.verb.irregularity.verb && type == 'irregular'){
						if(this.verb.irregularity.saver)
							suffixes = suffixes.concat(['.>ò']);
						else
							suffixes = suffixes.concat([(t.themeT8.match(/[aeiouàèéíòóú]$/)? '(g)': '') + 'o']);
					}
				}
				if(this.verb.irregularity.verb.match(/dixer|traer|toler/))
					suffixes = suffixes.concat(['[lx]>go']);
				upsert(this.paradigmEndings, 't8', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			if(t.themeT9){
				if(!this.verb.irregularity.poder)
					upsert(this.paradigmEndings, 't9', {parents: [this.verb.infinitive], suffixes: [PRONOMENAL_MARK_IMPERATIVE]});
			}
			if(t.themeT10){
				suffixes = [];
				if(!t.themeT8)
					suffixes = suffixes.concat(['']);
				if(!t.themeT8 || t.themeT10 !== t.themeT8 + (!this.verb.irregularity.verb.match(/darStarFar|s?aver/)? (this.verb.irregularity.eser? 'é': 'e'): ''))
					suffixes = suffixes.concat(['([ei])>($1)']);
				if(!t.themeT8 && t.themeT10.match(/[aeiou]$/) && t.themeT10 != PhonologyHelper.finalConsonantVoicing(t.themeT10.replace(/[ei]$/, ''), 'northern'))
					suffixes = suffixes.concat(['[ei]>+voicing']);
				if(suffixes.length)
					upsert(this.paradigmEndings, 't10', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			if(t.themeT12){
				suffixes = ['on', 'en'];
				if(conj != 2)
					suffixes = suffixes.concat(['é']);
				upsert(this.paradigmEndings, 't12', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
		}, this);
//		generateParticiplePerfect_strong.call(this);
		if(!this.verb.irregularity.eser){
			if(reg.themeT2){
				var tmp = (this.verb.irregularity.eser? 'r': '(v)');
				suffixes = [tmp + 'o', tmp + 'i', tmp + 'a', tmp + 'e', tmp + 'imo',
					'se', 'si', 'simo'];
				if(this.verb.conjugation == 2)
					suffixes = suffixes.concat(['í', 'imo']);
				upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			generateThemeT2_ndo.call(this, irr, pronomenalMark);
			generateThemeT4.call(this, irr);
			generateThemeT7.call(this, irr, pronomenalMark);
			if(reg.themeT11){
				suffixes = ['iv(i)on(se)', '(iv)en(se)', 'ivié',
					(!reg.themeT11.match(/[cijɉñ]$/)? '(i)': '') + 'on(e/se)', 'is(i)on(e/se)', '(is)en(e/se)', '(is)ié', '(is)ie(de/ge)'];
				upsert(this.paradigmEndings, 't11', {parents: [this.verb.infinitive], suffixes: suffixes});
			}

			if(this.verb.irregularity.aver){
				suffixes = [(this.verb.infinitive.substr(0, this.verb.infinitive.length - 'aver'.length)) + 'abiando' + pronomenalMark];
				upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
		}
		//ensure syncope does not occurs
		if(!this.verb.irregularity.verb.match(/dixer|poder|toler|voler|traer/)){
			if(irr.themeT2){
				var tmp = (this.verb.irregularity.eser? 'r': '(v)');
				suffixes = [tmp + 'o', tmp + 'i', tmp + 'a', tmp + 'e', tmp + 'imo'];
				upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			if(irr.themeT11){
				suffixes = [(!irr.themeT11.match(/[cijɉñ]$/)? '(i)': '') + 'on(se)', 'iv(i)on(se)', '(iv)en(se)', '(iv)ié'];
				upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
		}
		generateThemeT2_ndo.call(this, reg, pronomenalMark);
		if(irr.themeT2){
			suffixes = ['se', 'si', 'simo'];
			if(this.verb.conjugation == 2)
				suffixes = suffixes.concat(['í', 'imo']);
			upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
		generateThemeT4.call(this, reg);
		generateThemeT7.call(this, reg, pronomenalMark);
		//ensure syncope does not occurs
		if(!this.verb.irregularity.verb.match(/dever|eser|s?aver/)){
			generateThemeT5.call(this, REGULAR, reg);
			if(reg.themeT8){
				suffixes = ['a', 'e', '([^i])>$1i'];
				if(reg.themeT8.match(/[^aeiouàèéíòóú]$/))
					suffixes = suffixes.concat(['[ei]>+voicing']);
				if(this.verb.irregularity.verb.match(/dixer|traer|toler/))
					suffixes = suffixes.concat(['[lx]>g[ai]']);
				upsert(this.paradigmEndings, 't8', {parents: [this.verb.infinitive], suffixes: suffixes});
			}
			generateThemeT12.call(this, reg);
		}
		generateThemeT5.call(this, IRREGULAR, irr);
		if(irr.themeT8){
			suffixes = ['a', 'e', '([^i])>$1i'];
			if(irr.themeT8.match(/[^aeiouàèéíòóú]$/))
				suffixes = suffixes.concat(['[ei]>+voicing']);
			if(!this.verb.irregularity.verb.match(/(aver|dever|eser)/))
				suffixes = suffixes.concat([(irr.themeT8.match(/[aeiouàèéíòóú]$/)? '(g)': '') + 'a', (irr.themeT8.match(/[aeiouàèéíòóú]$/)? '(g)i': '([^i])>$1i')]);
			if(this.verb.irregularity.verb.match(/dixer|traer|toler/))
				suffixes = suffixes.concat(['[lx]>g[ai]']);
			upsert(this.paradigmEndings, 't8', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
		if(irr.themeT11){
			suffixes = [(!irr.themeT11.match(/[cijɉñ]$/)? '(i)': '') + 'on(e/se)', 'is(i)on(e/se)', '(is)en(e/se)', '(is)ié', '(is)ie(de/ge)'];
			upsert(this.paradigmEndings, 't11', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
		generateThemeT12.call(this, irr);

		if(this.verb.irregularity.eser){
			suffixes = ['siando' + pronomenalMark];
			upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
		else if(this.verb.irregularity.aver){
			suffixes = [(this.verb.infinitive.substr(0, this.verb.infinitive.length - 'aver'.length)) + 'abiando' + pronomenalMark];
			upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT1 = function(t, pronomenalMark){
		if(t.themeT1){
			var suffixes = ['r' + pronomenalMark, 're'];
			upsert(this.paradigmEndings, 't1', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT2_ndo = function(t, pronomenalMark){
		if(t.themeT2){
			var suffixes = ['ndo' + pronomenalMark];
			upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT2_sto = function(t){
		if(t.themeT2){
			var suffixes = ['sto', 'sti', 'sta', 'ste'];
			upsert(this.paradigmEndings, 't2', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT4 = function(t){
		if(t.themeT4){
			var suffixes = ['rò', 'rà', 'rè', 'ré', 'remo', 'ron', 'ren',
				'ría', 'ríe', 'resi', 'r(is)ié', 'résimo', 'r(is)(i)on(se)', 'r(is)en(se)',
				'rave'];
			if(this.verb.conjugation == 2)
				suffixes = suffixes.concat(['í', 'imo']);
			upsert(this.paradigmEndings, 't4', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT5 = function(type, t){
		if(t.themeT5){
			var suffixes = ['', 'è>e+mo'],
				conj = getIrregularVerbConjugation.call(this, type);
			if(conj == 2 && t.themeT5.replace(/i?é$/, 'í') != t.themeT5)
				suffixes = suffixes.concat(['i?é>í', 'i?é>i+mo']);
			else{
				suffixes = suffixes.concat(['[èí]>é']);
				if(conj == 3 && !this.verb.special3rd)
					suffixes = suffixes.concat(['(de/ge)']);
			}
			upsert(this.paradigmEndings, 't5', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT7 = function(t, pronomenalMark){
		if(t.themeT7 && this.verb.conjugation == 3){
			var suffixes = ['ndo' + pronomenalMark];
			upsert(this.paradigmEndings, 't7', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var generateThemeT12 = function(t){
		if(t.themeT12){
			var suffixes = [(!t.themeT12.match(/[cijɉñ]$/)? '(i)': '') + 'on(e)', 'en(e)', (this.verb.special3rd? '(i)': '') + 'é', (this.verb.special3rd? '(i)': '') + 'e(de/ge)'];
			upsert(this.paradigmEndings, 't12', {parents: [this.verb.infinitive], suffixes: suffixes});
		}
	};

	/** @private */
	var upsert = function(root, key, data){
		root[key] = root[key] || {};
		var idx = findIndex(root[key], function(el){ return equals(el.suffixes, data.suffixes); });
		if(idx >= 0){
			var prev = root[key][idx];
			if(prev.parents.indexOf(data.parents[0]) >= 0)
				return;

			prev.parents = prev.parents.concat(data.parents);
		}
		else{
			if(ObjectHelper.isObject(root[key]))
				root[key] = [];
			root[key].push(data);
		}
	};

	/** @private */
	var findIndex = function(array, predicate){
		for(var i = 0, len = array.length; i < len; i ++)
			if(predicate.call(array, array[i], i))
				return i;
		return -1;
	};

	/** @private */
	var equals = function(a, b){
		return (a.length == b.length && a.every(function(el, i){ return (el == b[i]); }));
	};

	/** @private */
	var getIrregularVerbConjugation = function(type){
		return (type == IRREGULAR && this.verb.irregularity.traer? 1: this.verb.conjugation);
	};


	Constructor.prototype = {
		constructor: Constructor,

		generate: generate
	};


	return Constructor;

});
