<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="author" content="Mauro Trevisan">
	<link rel="shortcut icon" href="../favicon.png" />

	<title>test</title>

	<script src="../app/AMDLoader.js"></script>

	<script>
		AMDLoader.config = {
			baseUrl: '../app',
			paths: {
				libs: '../libs'
			}
		};

		Array.prototype.getRegExp = function(){
			return (this[0].lenght == 1? '[' + this.join('') + ']': '(' + this.join('|') + ')');
		};
		Array.prototype.getNotRegExp = function(){
			return (this[0].lenght == 1? '[^' + this.join('') + ']': '(' + this.join('|') + ')');
		};
		Array.prototype.findIndex = function(predicate, scope){
			for(var i = 0, len = this.length; i < len; i ++)
				if(predicate.call(scope || this, this[i], i, this))
					return i;
			return -1;
		};
		Array.prototype.unique = function(){
			return this.filter(function(x, i){
				return (this.indexOf(x) == i);
			}, this);
		};
		Array.prototype.difference = function(a){
			return this.filter(function(x){
				return (a.indexOf(x) < 0);
			});
		};
		Array.prototype.equals = function(a){
			return (this.length == a.length && this.every(function(el, idx){ return (el == a[idx]); }));
		};
		var intersection = function(a){
//			if(a == null)
//				return [];
//			if(arguments.length === 1)
//				return a.unique();
//
//			var arr = Array.prototype.concat.apply([], Array.prototype.slice.call(arguments, 1));
//
//			return a.unique().filter(function(el){
//				return arr.some(function(cur){
//					return (cur == el);
//				});
//			});

			var argsLength = arguments.length,
				length = a.length,
				result = [],
				i, j, item;
			for(i = 0; i < length; i ++){
				item = a[i];
				if(result.indexOf(item) >= 0)
					continue;

				for(j = 1; j < argsLength; j ++)
					if(arguments[j].indexOf(item) < 0)
						break;

				if(j == argsLength)
					result.push(item);
			}
			return result;
		};
		var partition = function(list, predicate){
			var result = {};
			list.forEach(function(value, index){
				var key = predicate(value, index, list);
				if(key in result)
					result[key].push(value);
				else
					result[key] = [value];
			});
			return result;
		};

		var composeInfinitive = (function(){
			var themeVowel = ['à', 'é', 'e', 'í', 'í'];

			return function(v){
				return v.prefix + v.radix + themeVowel[v.conjugation - 1] + 'r';
			};
		})();

		var epurateListAndApplyFlag = function(list, flag, matcher, base){
			var matcherLength = matcher.replace(/\[.+\]|\(.+\)/g, '').length,
				replacement = Array.prototype.slice.call(arguments, 4, arguments.length),
				i, j, rep, repment, idx0, indices, parents,
				inters, p;
			matcher = new RegExp(matcher + '$');

			for(i = list.length - 1; i >= 0; i --){
				repment = list[i].replacement;
				if(list.hasOwnProperty(i) && repment.match(matcher)){
					rep = list[i].replaced;
					repment = repment.substr(0, repment.length - matcherLength);
					idx0 = indexOfReplacement(list, rep, repment + base);
					if(idx0 < 0)
						continue;

					indices = replacement.map(function(last){ return indexOfReplacement(list, rep, repment + last); });
					if(indices.some(function(el){ return (el < 0); }))
						continue;

					//here, all replacements are found

					parents = indices.map(function(i){ return list[i].parents; });
					parents.push(list[idx0].parents);
					if(!parents.every(function(p, i){ return p.equals(parents[(i + 1) % parents.length]); })){
						//extract common parts
						inters = intersection.apply(this, parents);
						if(!inters.length)
							//nothing can be done, continue
							continue;

						indices.every(function(el){
							el = list[el];
							p = el.parents.difference(inters);
							if(p.length){
								list.push({
									replaced: el.replaced,
									replacement: el.replacement,
									form: el.form,
									parents: p
								});
								el.parents = intersection(el.parents, inters);
							}
						});
					}

					//all the replacements shares the same parents

					list[idx0].replacement = list[idx0].replacement.replace(/(\/.+)?$/, '/' + flag);

					replacement.forEach(function(last){
						while((j = indexOfReplacement(list, rep, repment + last)) >= 0){
							if(j < i)
								i --;

							list.splice(j, 1);
						}
					});
				}
			}
		};

		var indexOfReplacement = function(list, replaced, replacement){
			return list.findIndex(function(el){ return (el.replaced == replaced && el.replacement == replacement); });
		};

		var extractIndexOfCommonPart = function(str1, str2){
			var i, len;
			for(i = 0, len = Math.min(str1.length, str2.length) - 1; i < len; i ++)
				if(str1[i] != str2[i])
					break;
			return i;
		};

		var extractCommonPartFromList = function(list){
			var form,
				j, len;
			list.forEach(function(obj, i){
				if(!i)
					form = obj;
				else{
					for(j = 0, len = Math.min(obj.length, form.length); j < len; j ++)
						if(obj[obj.length - j - 1] != form[form.length - j - 1])
							break;
					form = (j > 0? form.substr(form.length - j): '.');
				}
			});
			return form;
		};

		var applyReductions = function(list){
			epurateListAndApplyFlag(list, 'D', 'o', 'o', 'a', 'e', 'i');
			epurateListAndApplyFlag(list, 'EF', 'nse', 'n', 'ne', 'nse');
			epurateListAndApplyFlag(list, 'E', 'nse', 'n', 'nse');
			epurateListAndApplyFlag(list, 'G', '', '', 'a', 'e');
			epurateListAndApplyFlag(list, 'F', 'ne', 'n', 'ne');
			epurateListAndApplyFlag(list, 'H', '[àéí]', '', 'simo', 'vimo');
			epurateListAndApplyFlag(list, 'I', 'ò', 'ò', 'à', 'è');
			epurateListAndApplyFlag(list, 'J', 'ndo/B', 'ndo/B', 'n/EF', 'nte', 'rave');
			epurateListAndApplyFlag(list, 'K', 'de', 'de', 'ge');
			epurateListAndApplyFlag(list, 'L', 'on/EF', 'on/EF', 'ede/K', 'sen/EF', 'siede/K', 'sié', 'sion/EF', 'son/EF', 'ven/E', 'vion/E', 'vié', 'von/E', 'é');
			epurateListAndApplyFlag(list, 'M', 'on/E', 'on/E', 'mo', 'sen/E', 'sion/E', 'son/E', 'sié', 'é');
			epurateListAndApplyFlag(list, 'N', 'mo', 'mo', 'sen/EF', 'sion/EF', 'son/EF', 'sié', 'vié', 'é');
			epurateListAndApplyFlag(list, 'O', 'ron/E', 'ron/E', 'remo', 'ren/E', 'resi', 'rion/M', 'ré', 'résimo', 'rí/G', 'rò/I');
			epurateListAndApplyFlag(list, 'P', 'mo', 'mo', 'de/K', 'ndo/J', 'ron/O', 'se', 'si', 'sto/D', 'vo/D');
			epurateListAndApplyFlag(list, 'Q', 'í', 'í', 'é/H', 'ú/G');
		};

		var augmentForms = function(list){
			list.forEach(function(el){
				augmentSingleForm(el, 1, list);
			});
		};

		var augmentSingleForm = function(el, order, list){
			if(!el.extendedParents)
				el.extendedParents = collectParents(el, list);

			var current = extractVariability(el.form, order, el.parents),
				avoid = extractVariability(el.form, order, el.extendedParents),
				inters = intersection(avoid, current);
			if(inters.length)
				el.form = '*' + el.form;
			else if(el.extendedParents.indexOf(el.form) >= 0)
				el.form = (current.length > 0? current.getRegExp(): '') + el.form;
			else
				el.form = (avoid.length > 0? avoid.getNotRegExp(): '') + el.form;
		};

		var collectParents = function(el, list){
			var parents = [],
				matcher = new RegExp('^(\\*|\\[.+\\])?' + el.form.replace(/\*|\[.+\]|\(.+\)|\/.+$/g, '') + '(\/.+)?$');
			list.forEach(function(obj){
				if(obj != el && obj.form.match(matcher))
					parents = parents.concat(obj.parents);
			});
			return parents.unique().difference(el.parents);
		};

		var extractVariability = function(form, order, list){
			var formLength = form.replace(/\*|\[.+\]|\(.+\)|\/.+$/g, '').length,
				variability = [];
			list.forEach(function(obj){
				var idx = obj.length - formLength - order;
				variability.push(idx >= 0? obj.substr(idx, order): null);
			});
			return variability.unique().sort();
		};

		var extractUnfeasible = function(list){
			return partition(list, function(value){ return (value.form.indexOf('*') >= 0); });
		};

		var searchForParentSubdivision = function(el, order, list){
			var parents = el.parents,
				variability = extractVariability(el.form, order, el.extendedParents.concat(el.parents)),
				len = variability.length,
				constraint = [],
				i, v, isStarred;
			for(i = 0; i < len; i ++){
				v = variability[i];
				if(!v)
					continue;

				el.form = el.form.replace(/^(\*|\[.+\]|\(.+\))/, '');

				subdivideParentsIf(constraint.concat(v).getRegExp(), el, list);

				augmentSingleForm(el, order);

				//undo what has be done in subdivideParentsIf
				isStarred = (el.form.indexOf('*') >= 0);
				if(i < len - 1 || isStarred){
					list.pop();
					el.parents = parents;
				}
				else
					augmentSingleForm(list[list.length - 1], order);

				if(!isStarred)
					constraint.push(v);
			}

			if(!isStarred && constraint.length && el.form.indexOf('[') < 0){
				constraint = constraint.getRegExp();

				el.replaced = constraint + el.replaced;
				el.replacement = constraint + el.replacement;
				el.form = constraint + el.form;
			}
		};

		var subdivideParentsIf = function(constraint, el, list){
			var matcher = new RegExp(constraint + el.form + '$'),
				part = partition(el.extendedParents.concat(el.parents), function(value){ return !!value.match(matcher); });

			list.push({
				replaced: el.replaced,
				replacement: el.replacement,
				form: el.form,
				parents: part[false],
				extendedParents: el.extendedParents
			});
			el.parents = part[true];
		};

		var transfer = function(destination, list){
			var move = list.filter(function(el){ return (el.form.indexOf('*') < 0); }),
				i, el;

			move.forEach(function(el){ destination.push(el); });

			for(i = list.length - 1; i >= 0; i --){
				el = list[i];
				if(el.form.indexOf('*') < 0)
					list.splice(i, 1);
				else
					el.form = el.form.replace(/\*|\[.+\]|\(.+\)/g, '');
			}
		};

		/*var reduceForms = function(list){
			list.forEach(function(el){
				if(el.form.indexOf(']') < 0 && el.form.indexOf('*') < 0){
					var i = 0,
						idx0 = el.form.search(/[àèéíòóú]/),
						idx1 = el.form.length - el.replaced.length,
						form, matcher, parents;
					if(idx0 != 0 && idx1 > 0){
						do{
							form = el.form.substr(++ i);

							//collect parents that matches
							parents = [];
							matcher = new RegExp('^(\\*|.+\\])?' + form + '$');
							list.forEach(function(obj){
								if(obj != el && obj.form.match(matcher))
									parents = parents.concat(obj.parents);
							});
							parents = parents.unique().difference(el.parents);
						}while((idx0 < 0 || i < idx0) && i < idx1 && parents.length);

						if(!parents.length)
							el.form = form;
					}
				}
			});
		};*/

		var prettyPrint = function(list){
			var maxReplaced = list.reduce(function(previousValue, currentValue){ return Math.max(previousValue, currentValue.replaced.length); }, 0),
				maxReplacement = list.reduce(function(previousValue, currentValue){ return Math.max(previousValue, currentValue.replacement.length); }, 0),
				maxForm = list.reduce(function(previousValue, currentValue){ return Math.max(previousValue, currentValue.form.length); }, 0);
			list.map(function(el, idx){
				var text = 'SFX A ' + printPadded(el.replaced, maxReplaced) + ' ' + printPadded(el.replacement, maxReplacement)
					+ ' ' + printPadded(el.form, maxForm) + ' # ' + el.parents;
				list[idx] = text;
			});

			console.log('SFX A Y ' + list.length);
			list.sort().forEach(function(el){
				console.log(el);
			});
		};

		var printPadded = function(value, len){
			return value + Array(len - value.length + 1).join(' ');
		};


		require(['tools/lang/phonology/Word', 'tools/lang/morphology/Conjugator', 'tools/lang/data/VerbsDictionary', 'libs/jsonh'], function(Word, Conjugator, verbsDictionary, JSONH){
			verbsDictionary = JSONH.unpack(verbsDictionary);

			var list = [],
				forms,
				idx, data,
				part, externalList;
			verbsDictionary.forEach(function(infinitive){
				infinitive = composeInfinitive(infinitive);

				forms = Conjugator.extractForms(infinitive);

				infinitive = Word.unmarkDefaultStress(infinitive);

				forms.forEach(function(form){
					idx = extractIndexOfCommonPart(form, infinitive);

					data = {
						replaced: infinitive.substr(idx),
						replacement: form.substr(idx).replace(/(ndo|r)$/, '$1/B'),
						form: infinitive,
						parents: [infinitive]
					};

					idx = list.findIndex(function(el){ return (el.replaced == data.replaced && el.replacement == data.replacement); });
					if(idx < 0)
						list.push(data);
					else if(list[idx].parents.indexOf(data.parents[0]) < 0){
						list[idx].parents.push(data.parents[0]);
						//if(list[idx].form.indexOf('[') < 0)
							list[idx].form = extractCommonPartFromList(list[idx].parents);
					}
				});
			});

			applyReductions(list);

			augmentForms(list);

			part = extractUnfeasible(list);
			list = part[false];
			externalList = part[true];

			externalList.forEach(function(el){
				searchForParentSubdivision(el, 1, externalList);
			});

			transfer(list, externalList);

			externalList.forEach(function(el){
				searchForParentSubdivision(el, 2, externalList);
			});

			transfer(list, externalList);

			/*list.forEach(function(el){
				el.replaced = el.replaced.replace(/^\[.+\]|\(.+\)/, '');
				el.replacement = el.replacement.replace(/^\[.+\]|\(.+\)/, '');
			});/**/


//			reduceForms(list);


//			prettyPrint(list);
			prettyPrint(externalList);
		});/**/

		/*require(['tools/lang/phonology/Word', 'tools/lang/morphology/Conjugator', 'tools/lang/data/VerbsDictionary', 'libs/jsonh'], function(Word, Conjugator, verbsDictionary, JSONH){
			verbsDictionary = JSONH.unpack(verbsDictionary);

			var k, infinitive;
			for(k in verbsDictionary){
				infinitive = composeInfinitive(verbsDictionary[k]);
				infinitive = Word.unmarkDefaultStress(infinitive);

				console.log(infinitive + '/A');
			}
			console.log('done ' + verbsDictionary.length);
		});/**/

		/*require(['tools/lang/phonology/Orthography', 'tools/lang/data/VerbsDictionary', 'libs/jsonh'], function(Orthography, verbsDictionary, JSONH){
			verbsDictionary = JSONH.unpack(verbsDictionary);

			var k, infinitive;
			for(k in verbsDictionary){
				infinitive = composeInfinitive(verbsDictionary[k]);

				if(infinitive !== Orthography.correctOrthography(infinitive))
					console.log('error on form ' + infinitive);
			}
			console.log('done ' + verbsDictionary.length);
		});/**/
	</script>
</head>

<body>
</body>
</html>
